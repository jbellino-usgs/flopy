import sys
import numpy as np
from ..pakbase import Package
from ..utils.recarray_utils import create_empty_recarray


class ModflowFlwob(Package):
    """
    Head-dependent flow boundary Observation package class. Minimal working
    example that will be refactored in a future version.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modflow.mf.Modflow`) to which
        this package will be added.
    iufbobsv : int
        Unit number where output is saved.
    tomultfb : float
        Time-offset multiplier for head-dependent flow boundary observations.
        The product of tomultfb and toffset must produce a time value in units
        consistent with other model input. tomultfb can be dimensionless or
        can be used to convert the units of toffset to the time unit used in
        the simulation.
    obs_data : FlowObservation or list of FlowObservation instances
        Each FlowObservation instance contains all observations for each group
        of cells for which fluxes are desired. If obs_data
        is None a default FlowObservation with layer, row, column, factor
        (0, 0, 0, 1.) and a flux value of 0 at totim 0 will be created
        (default is None).
    flowtype : string
        String that corresponds to the head-dependent flow boundary condition
        type (CHD, GHB, DRN, RIV)
    extension : list of string
        Filename extension. If extension is None, extension is set to
        ['chob','obc','gbob','obg','drob','obd', 'rvob','obr'] (default is
        None).
    no_print : boolean
        When True or 1, a list of flow observations will not be
        written to the Listing File (default is False).
    options : list of strings
        Package options (default is None).
    unitnumber : list of int
        File unit number. If unitnumber is None, unitnumber is set to
        [40, 140, 41, 141, 42, 142, 43, 143] (default is None).
    filenames : str or list of str
        Filenames to use for the package and the output files. If
        filenames=None the package name will be created using the model name
        and package extension and the flwob output name will be created using
        the model name and .out extension (for example,
        modflowtest.out), if iufbobsv is a number greater than zero.
        If a single string is passed the package will be set to the string
        and flwob output name will be created using the model name and .out
        extension, if iufbobsv is a number greater than zero. To define the
        names for all package files (input and output) the length of the list
        of strings should be 2. Default is None.


    Attributes
    ----------

    Methods
    -------

    See Also
    --------

    Notes
    -----
    This represents a minimal working example that will be refactored in a
    future version.

    Examples
    --------


    """

    def __init__(self, model, iufbobsv=None, tomultfb=1.0, obs_data=None,
                 flowtype=None, extension=None, no_print=False, options=None,
                 unitnumber=None, filenames=None):

        """
        Package constructor
        """

        if extension is None:
            extension = ['chob', 'obc', 'gbob', 'obg', 'drob', 'obd',
                         'rvob', 'obr']
        pakunits = {'chob': 40,
                    'gbob': 41,
                    'drob': 42,
                    'rvob': 43}
        outunits = {'chob': 140,
                    'gbob': 141,
                    'drob': 142,
                    'rvob': 143}
        # if unitnumber is None:
        #     unitnumber = [40, 140, 41, 141, 42, 142, 43, 143]

        if flowtype.upper().strip() == 'CHD':
            name = ['CHOB', 'DATA']
            extension = extension[0:2]
            # unitnumber = unitnumber[0:2]
            # iufbobsv = unitnumber[1]
            self.url = 'chob.htm'
            self.heading = '# CHOB for MODFLOW, generated by Flopy.'
        elif flowtype.upper().strip() == 'GHB':
            name = ['GBOB', 'DATA']
            extension = extension[2:4]
            # unitnumber = unitnumber[2:4]
            # iufbobsv = unitnumber[1]
            self.url = 'gbob.htm'
            self.heading = '# GBOB for MODFLOW, generated by Flopy.'
        elif flowtype.upper().strip() == 'DRN':
            name = ['DROB', 'DATA']
            extension = extension[4:6]
            # unitnumber = unitnumber[4:6]
            # iufbobsv = unitnumber[1]
            self.url = 'drob.htm'
            self.heading = '# DROB for MODFLOW, generated by Flopy.'
        elif flowtype.upper().strip() == 'RIV':
            name = ['RVOB', 'DATA']
            extension = extension[6:8]
            # unitnumber = unitnumber[6:8]
            # iufbobsv = unitnumber[1]
            self.url = 'rvob.htm'
            self.heading = '# RVOB for MODFLOW, generated by Flopy.'
        else:
            msg = 'ModflowFlwob: flowtype must be CHD, GHB, DRN, or RIV'
            raise KeyError(msg)

        if unitnumber is None:
            unitnumber = [pakunits[name[0].lower()],
                          outunits[name[0].lower()]]
        elif isinstance(unitnumber, int):
            unitnumber = [unitnumber]
        if len(unitnumber) == 1:
            if unitnumber[0] in outunits.keys():
                unitnumber = [pakunits[name[0].lower()],
                              unitnumber[0]]
            else:
                unitnumber = [unitnumber[0],
                              outunits[name[0].lower()]]
        iufbobsv = unitnumber[1]

        # set filenames
        if filenames is None:
            filenames = [None, None]
        elif isinstance(filenames, str):
            filenames = [filenames, None]
        elif isinstance(filenames, list):
            if len(filenames) < 2:
                filenames.append(None)

        # call base package constructor
        Package.__init__(self, model, extension=extension, name=name,
                         unit_number=unitnumber,
                         allowDuplicates=True, filenames=filenames)

        self.tomultfb = tomultfb
        self.iufbobsv = iufbobsv

        # create default
        if obs_data is None:
            obs_data = FlowObservation()

        # make sure obs_data is a list
        if isinstance(obs_data, FlowObservation):
            obs_data = [obs_data]

        # add another check for obs_data is not None and not nested list?

        # set self.obs_data
        self.obs_data = obs_data

        self.no_print = no_print
        self.np = 0
        if options is None:
            options = []
        if self.no_print:
            options.append('NOPRINT')
        self.options = options

        # add checks for input compliance (obsnam length, etc.)
        self.parent.add_package(self)

        # determine the dimensions of FLWOB data
        self._set_dimensions()

    def _set_dimensions(self):
        """
        Set the length of the obs_data list

        Returns
        -------
        None

        """
        # make sure each entry of obs_data list is a FlowObservation instance
        # and calculate nqobfb and nqclfb
        msg = ''
        self.nqobfb = []
        self.nqclfb = []

        for idx, obs in enumerate(self.obs_data):
            if not isinstance(obs, FlowObservation):
                msg += 'ModflowFlwob: obs_data entry {} '.format(idx) + \
                       'is not a FlowObservation instance.\n'
                continue
            self.nqobfb.append(len(obs.time_series_data))
            self.nqclfb.append(len(obs.cell_group_data))

        self.nqfb = len(self.obs_data)
        self.nqcfb = sum(self.nqclfb)
        self.nqtfb = sum(self.nqobfb)

        if msg != '':
            raise ValueError(msg)
        return

    def write_file(self):
        """
        Write the package file

        Returns
        -------
        None

        """
        # open file for writing
        f_fbob = open(self.fn_path, 'w')

        # write header
        f_fbob.write('{}\n'.format(self.heading))

        # write sections 1 and 2 : NOTE- what about NOPRINT?
        line = '{:10d}'.format(self.nqfb)
        line += '{:10d}'.format(self.nqcfb)
        line += '{:10d}'.format(self.nqtfb)
        line += '{:10d}'.format(self.iufbobsv)
        if self.no_print or 'NOPRINT' in self.options:
            line += '{: >10}'.format('NOPRINT')
        line += '\n'
        f_fbob.write(line)
        f_fbob.write('{:10e}\n'.format(self.tomultfb))

        # write sections 3-5 looping through observations groups
        for i in range(self.nqfb):
            #        while (i < self.nqfb):
            # write section 3
            f_fbob.write('{:10d}{:10d}\n'.format(self.nqobfb[i],
                                                 self.nqclfb[i]))

            # Loop through observation times for the groups
            tsd = self.obs_data[i].time_series_data
            for j in range(self.nqobfb[i]):
                # write section 4
                line = '{:12}'.format(tsd.obsname[j].decode())
                line += '{:8d}'.format(tsd.irefsp[j] + 1)
                line += '{:16.10g}'.format(tsd.toffset[j])
                line += ' {:10.4g}\n'.format(tsd.flwobs[j])
                f_fbob.write(line)

            # write section 5 - NOTE- need to adjust factor for multiple
            # observations in the same cell
            for j in range(self.nqclfb[i]):
                line = '{:10d}'.format(self.obs_data[i].layer[j] + 1)
                line += '{:10d}'.format(self.obs_data[i].row[j] + 1)
                line += '{:10d}'.format(self.obs_data[i].column[j] + 1)
                # note is 10f good enough here?
                line += '{:10f}\n'.format(self.obs_data[i].factor[j])
                f_fbob.write(line)

        f_fbob.close()

        #
        # swm: BEGIN hack for writing standard file
        sfname = self.fn_path
        sfname += '_ins'

        # write header
        f_ins = open(sfname, 'w')
        f_ins.write('jif @\n')
        f_ins.write('StandardFile 0 1 {}\n'.format(self.nqtfb))
        for i in range(self.nqfb):
            obs = self.obs_data[i]
            for j in range(self.nqtfb):
                f_ins.write('{}\n'.format(obs.time_series_data[j].obsname))

        f_ins.close()
        # swm: END hack for writing standard file

        return

    @staticmethod
    def load(f, model, flowtype=None, ext_unit_dict=None, check=True):
        """
        Load an existing package.

        Parameters
        ----------
        f : filename or file handle
            File to load.
        model : model object
            The model object (of type :class:`flopy.modflow.mf.Modflow`) to
            which this package will be added.
        ext_unit_dict : dictionary, optional
            If the arrays in the file are specified using EXTERNAL,
            or older style array control records, then `f` should be a file
            handle.  In this case ext_unit_dict is required, which can be
            constructed using the function
            :class:`flopy.utils.mfreadnam.parsenamefile`.
        check : boolean
            Check package data for common errors. (default True)

        Returns
        -------
        flwob : ModflowFlwob package object
            ModflowFlwob package object.

        Examples
        --------

        >>> import flopy
        >>> m = flopy.modflow.Modflow()
        >>> hobs = flopy.modflow.ModflowFlwob.load('test.drob', m)

        """

        if model.verbose:
            sys.stdout.write('loading flwob package file...\n')

        if not hasattr(f, 'read'):
            filename = f
            f = open(filename, 'r')

        ext = None
        if flowtype is None:
            # attempt to infer flowtype
            ext = f.name.split('.')[-1].lower()
            if 'ch' in ext.lower():
                ext = 'chob'
                flowtype = 'CHD'
            elif 'gb' in ext.lower():
                ext = 'gbob'
                flowtype = 'GHB'
            elif 'dr' in ext.lower():
                ext = 'drob'
                flowtype = 'DRN'
            elif 'rv' in ext.lower():
                ext = 'rvob'
                flowtype = 'RIV'
            else:
                msg = 'ModflowFlwob: flowtype cannot be inferred ' \
                      'from file name {}'.format(f.name)
                raise KeyError(msg)

        # dataset 0 -- header
        while True:
            line = f.readline()
            if line[0] != '#':
                break

        # read dataset 1 -- NQFB NQCFB NQTFB IUFBOBSV Options
        t = line.strip().split()
        nqfb = int(t[0])
        nqcfb = int(t[1])
        nqtfb = int(t[2])
        iufbobsv = int(t[3])
        options = []
        if len(t) > 4:
            options = t[4:]

        # read dataset 2 -- TOMULTFB
        line = f.readline()
        t = line.strip().split()
        tomultfb = float(t[0])

        # read datasets 3, 4, and 5 for each of nqfb groups
        # of cells
        nobs = 0
        flwobs = []
        while True:

            # read dataset 3 -- NQOBFB NQCLFB
            line = f.readline()
            t = line.strip().split()
            nqobfb = int(t[0])
            nqclfb = int(t[1])

            # read dataset 4 -- OBSNAM IREFSP TOFFSET FLWOBS
            names = []
            tsd = []
            ntimes = 0
            while True:
                line = f.readline()
                t = line.strip().split()
                names.append(t[0])
                irefsp = int(t[1]) - 1
                toffset = float(t[2])
                flwob = float(t[3])
                totim = model.dis.get_totim_from_kper_toffset(irefsp,
                                                              toffset *
                                                              tomultfb)
                tsd.append([totim, flwob])
                ntimes += 1
                if ntimes == nqobfb:
                    break

            # read dataset 5 -- Layer Row Column Factor
            cgd = []
            ncells = 0
            while True:
                line = f.readline()
                t = line.strip().split()
                k = int(t[0]) - 1
                i = int(t[1]) - 1
                j = int(t[2]) - 1
                fac = float(t[3])
                cgd.append((k, i, j, fac))

                ncells += 1
                if ncells == abs(nqclfb):
                    break

            if nqclfb < 0:
                factor = np.ones(abs(nqclfb), np.float32)

            nobs += 1
            if nobs == nqfb:
                # create FlowObservation instance
                flwob = FlowObservation(model,
                                        tomultfb=tomultfb,
                                        cell_group_data=cgd,
                                        time_series_data=tsd,
                                        names=names)
                flwobs.append(flwob)
                break

        # close the file
        f.close()

        # set package unit number
        unitnumber = None
        filenames = [None, None]
        if ext_unit_dict is not None:
            unitnumber, filenames[0] = \
                model.get_ext_dict_attr(ext_unit_dict,
                                        filetype=ext.upper())
            if iufbobsv > 0:
                _, filenames[1] = \
                    model.get_ext_dict_attr(ext_unit_dict, unit=iufbobsv)
                model.add_pop_key_list(iufbobsv)

        # create ModflowFlwob object instance
        flwob = ModflowFlwob(model, iufbobsv=iufbobsv, tomultfb=tomultfb,
                             obs_data=flwobs, options=options,
                             flowtype=flowtype, unitnumber=unitnumber,
                             filenames=filenames)

        return flwob


class FlowObservation(object):
    """
    Create single FlowObservation instance. Each instance of this class
    consists of a group of one or more cells to which the associated
    timeseries data pertain. A list of FlowObservation instances are passed to
    the ModflowFlwob package.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modflow.mf.Modflow`) to which
        this package will be added.
    tomultfb : float
        Time-offset multiplier for flow observations. Default is 1.
    obsname : string
        Observation name. Default is 'FLWOBS'.
    cell_group_data : list of tuples
        Each tuple is defined by a layer(int), row(int), column(int), and
        factor(float), where factor is the portion of the simulated flow in the
        cell that is included in the total simulated flow for this cell group.
        This gives the form of::

            cell_group_data =
            [
                (layer, row, column, factor),
                (layer, row, column, factor),
                (layer, row, column, factor)
            ]

        Default is [(0, 0, 0, 1.)].
    time_series_data : list or numpy array
        Two-dimensional list or numpy array containing the simulation time of
        the observation and the observed flux [[totim, flwob]]. If
        time_series_data is None, a default observation of 0. at
        totim 0. will be created (default is None).
    names : list
        List of specified observation names. If names is None, observation
        names will be automatically generated from obsnam and the order
        of the timeseries data (default is None).

    Returns
    -------
    obs : FlowObservation
        FlowObservation object.

    Examples
    --------
    >>> import flopy
    >>> model = flopy.modflow.Modflow()
    >>> dis = flopy.modflow.ModflowDis(model, nlay=1, nrow=11, ncol=11, nper=2,
    ...                                perlen=[1,1])
    >>> tsd = [[1., -54.4], [2., -55.2]]
    >>> obsdata = flopy.modflow.FlowObservation(model, time_series_data=tsd)

    """
    def __init__(self, model, tomultfb=1., obsname='FLWOBS',
                 cell_group_data=None, time_series_data=None, names=None):

        """
        NOTES:

        1) ModflowFlwob also gets tomultfb (dataset 2), what to do here?

        2) irefsp doesn't actually get used when populating the timeseries
        data. kper is populated from model.dis.get_kstp_kper_toffset(t).
        References to irefsp have been removed.

        3) "obsname" is mistakenly listed as "obsnam" in the ModflowHob
        docstring.

        4) Explicitly pass factor for each cell in the cell group. Since we
        are using python there's no reason not to.

        5)

        """

        if cell_group_data is None:
            cell_group_data = [(0, 0, 0, 1.)]

        for idx, cgp in enumerate(cell_group_data):
            msg = 'Length of cell group {} must be 4; e.g. (layer, row, ' \
                  'column, factor).'.format(idx + 1)
            assert len(cgp) == 4, msg

            # convert negative factor values to 1.
            if cgp[3] < 0:
                cgp[3] = 1.

            # check type of each value?

        self.cell_group_data = cell_group_data
        self.layer = list([i[0] for i in cell_group_data])
        self.row = list([i[1] for i in cell_group_data])
        self.column = list([i[2] for i in cell_group_data])
        self.factor = list([i[3] for i in cell_group_data])

        # convert passed time_series_data to a numpy array
        if isinstance(time_series_data, list):
            time_series_data = np.array(time_series_data, dtype=np.float)

        # if a single observation is passed as a list reshape to a
        # two-dimensional numpy array
        if len(time_series_data.shape) == 1:
            time_series_data = np.reshape(time_series_data, (1, 2))

        # find indices of time series data that are valid
        tmax = model.dis.get_final_totim()
        keep_idx = time_series_data[:, 0] <= tmax
        time_series_data = time_series_data[keep_idx, :]

        # set the number of observations in this time series
        shape = time_series_data.shape
        self.nobs = shape[0]

        # construct names if not passed
        if names is None:
            if self.nobs == 1:
                names = [obsname]
            else:
                names = []
                for idx in range(self.nobs):
                    names.append('{}.{}'.format(obsname, idx + 1))
        # make sure the length of names is greater than or equal to nobs
        else:
            if isinstance(names, str):
                names = [names]
            elif not isinstance(names, list):
                msg = 'FlowObservation names must be a ' + \
                      'string or a list of strings'
                raise ValueError(msg)
            if len(names) < self.nobs:
                msg = 'a name must be specified for every valid ' + \
                      'observation - {} '.format(len(names)) + \
                      'names were passed but at least ' + \
                      '{} names are required.'.format(self.nobs)
                raise ValueError(msg)

        # create time_series_data
        self.time_series_data = self._get_empty(ncells=shape[0])
        for idx in range(self.nobs):
            t = time_series_data[idx, 0]
            kstp, kper, toffset = model.dis.get_kstp_kper_toffset(t)
            self.time_series_data[idx]['totim'] = t
            self.time_series_data[idx]['irefsp'] = kper
            self.time_series_data[idx]['toffset'] = toffset / tomultfb
            self.time_series_data[idx]['flwobs'] = time_series_data[idx, 1]
            self.time_series_data[idx]['obsname'] = names[idx]

        return

    def _get_empty(self, ncells=0):
        """
        Get an empty time_series_data recarray for a HeadObservation

        Parameters
        ----------
        ncells : int
            number of time entries in a HeadObservation

        Returns
        -------
        d : np.recarray

        """
        # get an empty recarray that corresponds to dtype
        dtype = self._get_dtype()
        d = create_empty_recarray(ncells, dtype, default_value=-1.0E+10)
        d['obsname'] = ''
        return d

    @staticmethod
    def _get_dtype():
        """
        Get the dtype for FlowObservation time_series_data


        Returns
        -------
        dtype : np.dtype

        """
        # get the default FLWOB dtype
        dtype = np.dtype([("totim", np.float32),
                          ("irefsp", np.int),
                          ("toffset", np.float32),
                          ("flwobs", np.float32),
                          ("obsname", '|S12')])
        return dtype